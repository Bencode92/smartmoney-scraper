"\"\"Backtest & Benchmark - Compare le portefeuille au S&P 500\"\"\"\nimport json\nimport time\nfrom datetime import datetime, timedelta\nfrom pathlib import Path\nimport requests\nimport numpy as np\nimport pandas as pd\n\nimport sys\nsys.path.append(str(Path(__file__).parent.parent))\nfrom config import OUTPUTS, TWELVE_DATA_KEY, TWELVE_DATA_BASE, TWELVE_DATA_RATE_LIMIT\n\n\nclass Backtester:\n    \"\"\"Backtest du portefeuille et comparaison avec benchmark\"\"\"\n    \n    def __init__(self):\n        self._last_api_call = 0\n        self.benchmark_symbol = \"SPY\"  # S&P 500 ETF\n        self.results = {}\n    \n    def _rate_limit(self):\n        \"\"\"Respecte le rate limit Twelve Data\"\"\"\n        elapsed = time.time() - self._last_api_call\n        wait = (60 / TWELVE_DATA_RATE_LIMIT) - elapsed\n        if wait > 0:\n            time.sleep(wait)\n        self._last_api_call = time.time()\n    \n    def _fetch_time_series(self, symbol: str, outputsize: int = 252) -> pd.DataFrame:\n        \"\"\"R√©cup√®re l'historique de prix\"\"\"\n        if not TWELVE_DATA_KEY:\n            return pd.DataFrame()\n        \n        self._rate_limit()\n        try:\n            resp = requests.get(\n                f\"{TWELVE_DATA_BASE}/time_series\",\n                params={\n                    \"symbol\": symbol,\n                    \"interval\": \"1day\",\n                    \"outputsize\": outputsize,\n                    \"apikey\": TWELVE_DATA_KEY\n                },\n                timeout=15\n            )\n            if resp.status_code == 200:\n                data = resp.json()\n                if \"values\" in data:\n                    df = pd.DataFrame(data[\"values\"])\n                    df[\"datetime\"] = pd.to_datetime(df[\"datetime\"])\n                    df[\"close\"] = df[\"close\"].astype(float)\n                    df = df.sort_values(\"datetime\")\n                    return df[[\"datetime\", \"close\"]]\n        except Exception as e:\n            print(f\"‚ö†Ô∏è Time series error {symbol}: {e}\")\n        return pd.DataFrame()\n    \n    def load_portfolio_history(self) -> list:\n        \"\"\"Charge l'historique des portefeuilles g√©n√©r√©s\"\"\"\n        # Cherche dans les sous-dossiers dat√©s\n        history = []\n        \n        for dated_dir in sorted(OUTPUTS.iterdir()):\n            if dated_dir.is_dir() and dated_dir.name != \"latest\":\n                portfolio_file = dated_dir / \"portfolio.json\"\n                if portfolio_file.exists():\n                    try:\n                        with open(portfolio_file) as f:\n                            data = json.load(f)\n                            history.append({\n                                \"date\": dated_dir.name,\n                                \"file\": portfolio_file.name,\n                                \"positions\": len(data.get(\"portfolio\", [])),\n                                \"portfolio\": data.get(\"portfolio\", []),\n                                \"metrics\": data.get(\"metrics\", {})\n                            })\n                    except Exception as e:\n                        print(f\"‚ö†Ô∏è Error loading {portfolio_file}: {e}\")\n        \n        return history\n    \n    def calculate_turnover(self, portfolio_old: list, portfolio_new: list) -> dict:\n        \"\"\"Calcule le turnover entre deux portefeuilles\"\"\"\n        symbols_old = {p[\"symbol\"]: p[\"weight\"] for p in portfolio_old}\n        symbols_new = {p[\"symbol\"]: p[\"weight\"] for p in portfolio_new}\n        \n        all_symbols = set(symbols_old.keys()) | set(symbols_new.keys())\n        \n        # Entr√©es et sorties\n        entries = set(symbols_new.keys()) - set(symbols_old.keys())\n        exits = set(symbols_old.keys()) - set(symbols_new.keys())\n        unchanged = set(symbols_old.keys()) & set(symbols_new.keys())\n        \n        # Turnover = somme des changements de poids / 2\n        total_change = 0\n        for symbol in all_symbols:\n            old_weight = symbols_old.get(symbol, 0)\n            new_weight = symbols_new.get(symbol, 0)\n            total_change += abs(new_weight - old_weight)\n        \n        turnover = total_change / 2  # On divise par 2 car chaque changement est compt√© 2x\n        \n        return {\n            \"turnover_pct\": round(turnover * 100, 2),\n            \"entries\": list(entries),\n            \"exits\": list(exits),\n            \"entries_count\": len(entries),\n            \"exits_count\": len(exits),\n            \"unchanged_count\": len(unchanged)\n        }\n    \n    def fetch_benchmark(self, days: int = 252) -> pd.DataFrame:\n        \"\"\"R√©cup√®re l'historique du benchmark (SPY)\"\"\"\n        print(f\"üìä R√©cup√©ration benchmark {self.benchmark_symbol}...\")\n        return self._fetch_time_series(self.benchmark_symbol, days)\n    \n    def calculate_portfolio_returns(self, portfolio: list, days: int = 90) -> pd.DataFrame:\n        \"\"\"Calcule les rendements du portefeuille bas√© sur les poids\"\"\"\n        print(f\"üìà Calcul des rendements pour {len(portfolio)} positions...\")\n        \n        # R√©cup√®re les prix pour chaque position\n        price_data = {}\n        for pos in portfolio:\n            symbol = pos[\"symbol\"]\n            weight = pos[\"weight\"]\n            \n            df = self._fetch_time_series(symbol, days)\n            if not df.empty:\n                price_data[symbol] = {\n                    \"prices\": df,\n                    \"weight\": weight\n                }\n                print(f\"  ‚úì {symbol}\")\n        \n        if not price_data:\n            return pd.DataFrame()\n        \n        # Trouve les dates communes\n        all_dates = None\n        for symbol, data in price_data.items():\n            dates = set(data[\"prices\"][\"datetime\"])\n            if all_dates is None:\n                all_dates = dates\n            else:\n                all_dates = all_dates & dates\n        \n        if not all_dates:\n            return pd.DataFrame()\n        \n        all_dates = sorted(all_dates)\n        \n        # Calcule les rendements pond√©r√©s\n        portfolio_values = []\n        for date in all_dates:\n            daily_return = 0\n            for symbol, data in price_data.items():\n                prices = data[\"prices\"]\n                price_row = prices[prices[\"datetime\"] == date]\n                if not price_row.empty:\n                    daily_return += data[\"weight\"] * price_row[\"close\"].values[0]\n            portfolio_values.append({\"datetime\": date, \"value\": daily_return})\n        \n        df = pd.DataFrame(portfolio_values)\n        df[\"return\"] = df[\"value\"].pct_change()\n        return df\n    \n    def compare_to_benchmark(self, portfolio: list, days: int = 90) -> dict:\n        \"\"\"Compare le portefeuille au benchmark\"\"\"\n        print(\"\\n\" + \"=\"*60)\n        print(\"üìä BACKTEST vs BENCHMARK\")\n        print(\"=\"*60)\n        \n        # Benchmark\n        bench_df = self.fetch_benchmark(days)\n        if bench_df.empty:\n            return {\"error\": \"Impossible de r√©cup√©rer le benchmark\"}\n        \n        bench_df[\"return\"] = bench_df[\"close\"].pct_change()\n        bench_total_return = (bench_df[\"close\"].iloc[-1] / bench_df[\"close\"].iloc[0] - 1) * 100\n        bench_vol = bench_df[\"return\"].std() * np.sqrt(252) * 100\n        \n        # Portefeuille (approximation bas√©e sur perf_3m pond√©r√©e)\n        portfolio_return = sum(p.get(\"weight\", 0) * (p.get(\"perf_3m\", 0) or 0) for p in portfolio)\n        portfolio_vol = np.sqrt(sum(p.get(\"weight\", 0)**2 * ((p.get(\"vol_30d\", 25) or 25)/100)**2 for p in portfolio)) * 100\n        \n        # Alpha et Sharpe\n        risk_free_rate = 4.5  # Taux sans risque actuel ~4.5%\n        alpha = portfolio_return - bench_total_return\n        sharpe_portfolio = (portfolio_return - risk_free_rate/4) / portfolio_vol if portfolio_vol > 0 else 0\n        sharpe_bench = (bench_total_return - risk_free_rate/4) / bench_vol if bench_vol > 0 else 0\n        \n        results = {\n            \"period_days\": days,\n            \"benchmark\": {\n                \"symbol\": self.benchmark_symbol,\n                \"return_pct\": round(bench_total_return, 2),\n                \"volatility_pct\": round(bench_vol, 2),\n                \"sharpe\": round(sharpe_bench, 2)\n            },\n            \"portfolio\": {\n                \"return_pct\": round(portfolio_return, 2),\n                \"volatility_pct\": round(portfolio_vol, 2),\n                \"sharpe\": round(sharpe_portfolio, 2),\n                \"positions\": len(portfolio)\n            },\n            \"comparison\": {\n                \"alpha_pct\": round(alpha, 2),\n                \"outperformance\": alpha > 0,\n                \"sharpe_diff\": round(sharpe_portfolio - sharpe_bench, 2)\n            }\n        }\n        \n        self.results = results\n        return results\n    \n    def calculate_drawdown(self, returns: pd.Series) -> dict:\n        \"\"\"Calcule le drawdown maximum\"\"\"\n        cumulative = (1 + returns).cumprod()\n        running_max = cumulative.cummax()\n        drawdown = (cumulative - running_max) / running_max\n        \n        max_dd = drawdown.min() * 100\n        max_dd_date = drawdown.idxmin() if not drawdown.empty else None\n        \n        return {\n            \"max_drawdown_pct\": round(max_dd, 2),\n            \"max_drawdown_date\": str(max_dd_date) if max_dd_date else None\n        }\n    \n    def generate_report(self, portfolio: list, output_dir: Path) -> Path:\n        \"\"\"\n        G√©n√®re un rapport de backtest complet.\n        \n        Args:\n            portfolio: Liste des positions\n            output_dir: Dossier dat√© (ex: outputs/2025-11-28/)\n        \"\"\"\n        # S'assurer que le dossier existe\n        output_dir = Path(output_dir)\n        output_dir.mkdir(parents=True, exist_ok=True)\n        \n        # Compare au benchmark\n        comparison = self.compare_to_benchmark(portfolio)\n        \n        # Charge l'historique pour calculer le turnover\n        history = self.load_portfolio_history()\n        turnover = None\n        if len(history) >= 2:\n            turnover = self.calculate_turnover(\n                history[-2][\"portfolio\"],\n                history[-1][\"portfolio\"]\n            )\n        \n        report = {\n            \"generated_at\": datetime.now().isoformat(),\n            \"benchmark_comparison\": comparison,\n            \"turnover\": turnover,\n            \"portfolio_history\": [\n                {\n                    \"date\": h[\"date\"],\n                    \"positions\": h[\"positions\"],\n                    \"perf_3m\": h[\"metrics\"].get(\"perf_3m\")\n                }\n                for h in history\n            ]\n        }\n        \n        # Export JSON (sans suffixe de date)\n        report_path = output_dir / \"backtest.json\"\n        with open(report_path, \"w\") as f:\n            json.dump(report, f, indent=2, default=str)\n        \n        # Affichage\n        print(\"\\n\" + \"-\"*60)\n        print(\"üìä R√âSULTATS\")\n        print(\"-\"*60)\n        \n        if \"error\" not in comparison:\n            print(f\"\\nüéØ PORTEFEUILLE:\")\n            print(f\"   Return: {comparison['portfolio']['return_pct']:+.2f}%\")\n            print(f\"   Vol: {comparison['portfolio']['volatility_pct']:.2f}%\")\n            print(f\"   Sharpe: {comparison['portfolio']['sharpe']:.2f}\")\n            \n            print(f\"\\nüìà BENCHMARK ({comparison['benchmark']['symbol']}):\")\n            print(f\"   Return: {comparison['benchmark']['return_pct']:+.2f}%\")\n            print(f\"   Vol: {comparison['benchmark']['volatility_pct']:.2f}%\")\n            print(f\"   Sharpe: {comparison['benchmark']['sharpe']:.2f}\")\n            \n            print(f\"\\n‚ö° ALPHA: {comparison['comparison']['alpha_pct']:+.2f}%\")\n            status = \"‚úÖ OUTPERFORM\" if comparison['comparison']['outperformance'] else \"‚ùå UNDERPERFORM\"\n            print(f\"   {status}\")\n        \n        if turnover:\n            print(f\"\\nüîÑ TURNOVER:\")\n            print(f\"   {turnover['turnover_pct']:.1f}% du portefeuille\")\n            print(f\"   Entr√©es: {turnover['entries_count']} | Sorties: {turnover['exits_count']}\")\n        \n        print(f\"\\nüìÅ Rapport export√©: {report_path.name}\")\n        return report_path\n\n\ndef run_backtest():\n    \"\"\"Lance le backtest sur le dernier portefeuille\"\"\"\n    # Cherche le dernier dossier dat√©\n    dated_dirs = sorted([\n        d for d in OUTPUTS.iterdir() \n        if d.is_dir() and d.name != \"latest\"\n    ])\n    \n    if not dated_dirs:\n        print(\"‚ùå Aucun portefeuille trouv√©\")\n        return\n    \n    latest_dir = dated_dirs[-1]\n    portfolio_file = latest_dir / \"portfolio.json\"\n    \n    if not portfolio_file.exists():\n        print(f\"‚ùå Fichier non trouv√©: {portfolio_file}\")\n        return\n    \n    print(f\"üìÇ Chargement: {portfolio_file}\")\n    \n    with open(portfolio_file) as f:\n        data = json.load(f)\n    \n    portfolio = data.get(\"portfolio\", [])\n    \n    # Lance le backtest\n    backtester = Backtester()\n    backtester.generate_report(portfolio, latest_dir)\n\n\nif __name__ == \"__main__\":\n    run_backtest()\n"